# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1btnoqWxUC39hcMYKlI8PUSb1RQfJjC14
"""

"""
å°å­—ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºãƒšãƒ¼ã‚¸
"""

import streamlit as st
import pandas as pd
from src.gis_handler import GISHandler

class KozuPage:
    def __init__(self, app):
        self.app = app
        self.gis_handler = GISHandler()

    def render(self):
        """å°å­—ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºãƒšãƒ¼ã‚¸ã‚’æç”»"""
        st.title("ğŸ—ºï¸ å°å­—ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºãƒ„ãƒ¼ãƒ«")

        if not self.gis_handler.is_gis_available():
            st.error("âš ï¸ GISæ©Ÿèƒ½ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚GeoPandasã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ãã ã•ã„ã€‚")
            return

        # ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚»ã‚¯ã‚·ãƒ§ãƒ³
        self._render_file_section()

        # GISãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å ´åˆ
        if st.session_state.get('gdf') is not None:
            self._render_extraction_section()

    def _render_file_section(self):
        """ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚»ã‚¯ã‚·ãƒ§ãƒ³"""
        st.header("ğŸ“ GISãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿")

        # ã‚¿ãƒ–ã§èª­ã¿è¾¼ã¿æ–¹æ³•ã‚’é¸æŠ
        tab1, tab2, tab3 = st.tabs(["ğŸ“‚ ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰æ¤œç´¢", "ğŸ”— ç›´æ¥URL", "ğŸ“¤ ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰"])

        with tab1:
            self._render_folder_search()

        with tab2:
            self._render_url_input()

        with tab3:
            self._render_file_upload()

    def _render_folder_search(self):
        """ãƒ•ã‚©ãƒ«ãƒ€æ¤œç´¢ã‚¿ãƒ–"""
        st.subheader("GitHubãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰æ¤œç´¢")

        folder_url = st.text_input(
            "GitHubãƒ•ã‚©ãƒ«ãƒ€URL:",
            placeholder="https://github.com/username/repository/tree/main/data",
            help="GitHubã®ãƒ•ã‚©ãƒ«ãƒ€URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"
        )

        if st.button("ğŸ” ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢"):
            if folder_url:
                with st.spinner("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢ã—ã¦ã„ã¾ã™..."):
                    files = self.gis_handler.get_files_from_web_folder(folder_url, ['.zip', '.shp'])

                    if files:
                        st.success(f"âœ… {len(files)}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ")

                        # ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ
                        file_options = {f"{f['name']} ({f['size']} bytes)": f['url'] for f in files}
                        selected_file = st.selectbox("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ:", ["é¸æŠã—ã¦ãã ã•ã„"] + list(file_options.keys()))

                        if selected_file != "é¸æŠã—ã¦ãã ã•ã„":
                            if st.button("ğŸ“¥ é¸æŠãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿"):
                                file_url = file_options[selected_file]
                                self._load_gis_data(file_url)
                    else:
                        st.warning("âš ï¸ å¯¾å¿œã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")

    def _render_url_input(self):
        """URLå…¥åŠ›ã‚¿ãƒ–"""
        st.subheader("ç›´æ¥URLæŒ‡å®š")

        file_url = st.text_input(
            "GISãƒ•ã‚¡ã‚¤ãƒ«URL:",
            placeholder="https://example.com/data.zip",
            help="ZIPãƒ•ã‚¡ã‚¤ãƒ«ã€Shapefileã€KMLãƒ•ã‚¡ã‚¤ãƒ«ã®URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"
        )

        if st.button("ğŸ“¥ URLã‹ã‚‰èª­ã¿è¾¼ã¿"):
            if file_url:
                self._load_gis_data(file_url)

    def _render_file_upload(self):
        """ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¿ãƒ–"""
        st.subheader("ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰")

        uploaded_file = st.file_uploader(
            "GISãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„",
            type=['zip', 'shp', 'kml', 'geojson'],
            help="ZIPã€Shapefileã€KMLã€GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™"
        )

        if uploaded_file is not None:
            if st.button("ğŸ“¥ ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿"):
                # ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã—ã¦èª­ã¿è¾¼ã¿
                import tempfile
                with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
                    tmp_file.write(uploaded_file.read())
                    tmp_path = tmp_file.name

                self._load_gis_data(tmp_path)

    def _load_gis_data(self, file_path_or_url):
        """GISãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿"""
        try:
            with st.spinner("GISãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™..."):
                gdf = self.gis_handler.load_gis_data(file_path_or_url)

                if gdf is not None:
                    st.session_state.gdf = gdf
                    st.success(f"âœ… GISãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼ˆ{len(gdf)}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ï¼‰")

                    # ãƒ‡ãƒ¼ã‚¿æ¦‚è¦ã‚’è¡¨ç¤º
                    st.subheader("ğŸ“Š ãƒ‡ãƒ¼ã‚¿æ¦‚è¦")
                    col1, col2, col3 = st.columns(3)

                    with col1:
                        st.metric("ãƒ¬ã‚³ãƒ¼ãƒ‰æ•°", len(gdf))

                    with col2:
                        st.metric("åˆ—æ•°", len(gdf.columns))

                    with col3:
                        crs_info = str(gdf.crs) if gdf.crs else "ä¸æ˜"
                        st.metric("æŠ•å½±æ³•", crs_info[:10] + "..." if len(crs_info) > 10 else crs_info)

                    # åˆ—æƒ…å ±
                    st.write("**åˆ©ç”¨å¯èƒ½ãªåˆ—:**")
                    st.write(list(gdf.columns))

                    # ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿
                    with st.expander("ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤º"):
                        st.dataframe(gdf.head())

        except Exception as e:
            st.error(f"ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {str(e)}")

    def _render_extraction_section(self):
        """ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºã‚»ã‚¯ã‚·ãƒ§ãƒ³"""
        st.markdown("---")
        st.header("ğŸ¯ ãƒ‡ãƒ¼ã‚¿æŠ½å‡º")

        gdf = st.session_state.gdf

        # å¿…è¦ãªåˆ—ã®å­˜åœ¨ç¢ºèª
        required_columns = ['å¤§å­—å', 'åœ°ç•ª']
        missing_columns = [col for col in required_columns if col not in gdf.columns]

        if missing_columns:
            st.error(f"å¿…è¦ãªåˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {missing_columns}")
            st.info("å¿…è¦ãªåˆ—: å¤§å­—å, åœ°ç•ª")
            return

        # æŠ½å‡ºæ¡ä»¶å…¥åŠ›
        col1, col2 = st.columns(2)

        with col1:
            # å¤§å­—é¸æŠ
            oaza_options = sorted(gdf['å¤§å­—å'].dropna().unique())
            selected_oaza = st.selectbox("å¤§å­—å:", ["é¸æŠã—ã¦ãã ã•ã„"] + oaza_options)

            # å°å­—é¸æŠï¼ˆå¤§å­—ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰
            selected_koaza = None
            if selected_oaza != "é¸æŠã—ã¦ãã ã•ã„":
                koaza_options = self.gis_handler.get_koaza_options(gdf, selected_oaza)
                if koaza_options:
                    selected_koaza = st.selectbox("å°å­—å:", ["é¸æŠãªã—"] + koaza_options)

        with col2:
            # ä¸ç›®é¸æŠï¼ˆå¤§å­—ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰
            selected_chome = None
            if selected_oaza != "é¸æŠã—ã¦ãã ã•ã„":
                chome_options = self.gis_handler.get_chome_options(gdf, selected_oaza)
                if chome_options:
                    selected_chome = st.selectbox("ä¸ç›®å:", ["é¸æŠãªã—"] + chome_options)

            # åœ°ç•ªå…¥åŠ›
            chiban = st.text_input("åœ°ç•ª:", placeholder="ä¾‹: 123")

            # æ¤œç´¢ç¯„å›²
            range_m = st.number_input("æ¤œç´¢ç¯„å›²ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰:", min_value=10, max_value=1000, value=100, step=10)

        # æŠ½å‡ºå®Ÿè¡Œ
        if st.button("ğŸ¯ ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º", type="primary"):
            if selected_oaza == "é¸æŠã—ã¦ãã ã•ã„":
                st.error("å¤§å­—åã‚’é¸æŠã—ã¦ãã ã•ã„")
            elif not chiban:
                st.error("åœ°ç•ªã‚’å…¥åŠ›ã—ã¦ãã ã•ã„")
            else:
                self._execute_extraction(selected_oaza, selected_chome, selected_koaza, chiban, range_m)

    def _execute_extraction(self, oaza, chome, koaza, chiban, range_m):
        """ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºã‚’å®Ÿè¡Œ"""
        gdf = st.session_state.gdf

        with st.spinner("ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã—ã¦ã„ã¾ã™..."):
            df_summary, overlay_gdf, message = self.gis_handler.extract_kozu_data(
                gdf, oaza, chome, koaza, chiban, range_m
            )

            if df_summary is not None and overlay_gdf is not None:
                st.success(f"âœ… æŠ½å‡ºå®Œäº†: {message}")

                # çµæœã‚’è¡¨ç¤º
                self._display_extraction_results(df_summary, overlay_gdf, oaza, chome, koaza, chiban)
            else:
                st.error(f"âŒ æŠ½å‡ºå¤±æ•—: {message}")

    def _display_extraction_results(self, df_summary, overlay_gdf, oaza, chome, koaza, chiban):
        """æŠ½å‡ºçµæœã‚’è¡¨ç¤º"""
        st.markdown("---")
        st.header("ğŸ“Š æŠ½å‡ºçµæœ")

        # æŠ½å‡ºæ¡ä»¶ã®è¡¨ç¤º
        col1, col2 = st.columns(2)

        with col1:
            st.subheader("ğŸ¯ æŠ½å‡ºæ¡ä»¶")
            st.write(f"**å¤§å­—å:** {oaza}")
            if chome and chome != "é¸æŠãªã—":
                st.write(f"**ä¸ç›®å:** {chome}")
            if koaza and koaza != "é¸æŠãªã—":
                st.write(f"**å°å­—å:** {koaza}")
            st.write(f"**åœ°ç•ª:** {chiban}")

        with col2:
            st.subheader("ğŸ“ˆ çµæœçµ±è¨ˆ")
            st.metric("å¯¾è±¡ç­†æ•°", len(df_summary))
            st.metric("å‘¨è¾ºç­†æ•°", len(overlay_gdf))

        # ã‚¿ãƒ–ã§çµæœã‚’è¡¨ç¤º
        tab1, tab2, tab3 = st.tabs(["ğŸ¯ å¯¾è±¡ç­†", "ğŸ—ºï¸ å‘¨è¾ºç­†", "ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰"])

        with tab1:
            st.subheader("å¯¾è±¡ç­†ãƒ‡ãƒ¼ã‚¿")
            if not df_summary.empty:
                st.dataframe(df_summary)

                # å¯¾è±¡ç­†ã®è©³ç´°æƒ…å ±
                if len(df_summary) == 1:
                    st.info("âœ… å¯¾è±¡ç­†ãŒ1ä»¶ç‰¹å®šã•ã‚Œã¾ã—ãŸ")
                else:
                    st.warning(f"âš ï¸ å¯¾è±¡ç­†ãŒ{len(df_summary)}ä»¶è¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚æ¡ä»¶ã‚’çµã‚Šè¾¼ã‚“ã§ãã ã•ã„ã€‚")
            else:
                st.info("å¯¾è±¡ç­†ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")

        with tab2:
            st.subheader("å‘¨è¾ºç­†ãƒ‡ãƒ¼ã‚¿")
            if not overlay_gdf.empty:
                st.dataframe(overlay_gdf)

                # å‘¨è¾ºç­†ã®çµ±è¨ˆ
                if 'å¤§å­—å' in overlay_gdf.columns:
                    oaza_counts = overlay_gdf['å¤§å­—å'].value_counts()
                    st.write("**å¤§å­—åˆ¥ä»¶æ•°:**")
                    st.bar_chart(oaza_counts)
            else:
                st.info("å‘¨è¾ºç­†ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")

        with tab3:
            st.subheader("ãƒ‡ãƒ¼ã‚¿ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰")

            col1, col2 = st.columns(2)

            with col1:
                if not df_summary.empty:
                    # å¯¾è±¡ç­†ã‚’CSVå½¢å¼ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                    csv_data = df_summary.to_csv(index=False, encoding='utf-8-sig')
                    st.download_button(
                        label="ğŸ“¥ å¯¾è±¡ç­†ãƒ‡ãƒ¼ã‚¿ (CSV)",
                        data=csv_data,
                        file_name=f"target_lots_{oaza}_{chiban}.csv",
                        mime="text/csv"
                    )

            with col2:
                if not overlay_gdf.empty:
                    # å‘¨è¾ºç­†ã‚’CSVå½¢å¼ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                    csv_data = overlay_gdf.to_csv(index=False, encoding='utf-8-sig')
                    st.download_button(
                        label="ğŸ“¥ å‘¨è¾ºç­†ãƒ‡ãƒ¼ã‚¿ (CSV)",
                        data=csv_data,
                        file_name=f"surrounding_lots_{oaza}_{chiban}.csv",
                        mime="text/csv"
                    )

        # çµæœã‚’ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹ã«ä¿å­˜
        st.session_state.extraction_results = {
            'target': df_summary,
            'surrounding': overlay_gdf,
            'conditions': {'oaza': oaza, 'chome': chome, 'koaza': koaza, 'chiban': chiban}
        }